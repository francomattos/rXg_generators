#Start generate account
def generate_account(account_count, token_count, data_file, group_select)

    #set default values for account tokens and tokens
    account_count = 1 if account_count.nil?
    token_count = 0 if token_count.nil?
    
    #List of account information
    first_names = %w( Aaron Abby Abigail Adam Addison Aiden Alexander Alexis Allison Alyssa Amanda Amelia Andrew Angelina Anna Anthony Arianna Ashley Audrey Austin Ava Avery Bailey Benjamin Blake Brady Brandon Brendan Brian Brody Brooke Bryce Caden Caleb Cameron Camryn Caroline Carson Carter Charlie Charlotte Chase Chloe Christian Christopher Claire Cole Colin Connor Cooper Daniel David Destiny Devin Dominic Drew Dylan Elijah Elizabeth Ella Ellie Emily Emma Eric Erin Ethan Evan Faith Gabriel Gavin Gianna Grace Gracie Hailey Hannah Hayden Henry Hunter Ian Isaac Isabelle Isaiah Jack Jackson Jacob Jake James Jasmine Jason Jayden Jenna Jessica John Jonathan Jordan Joseph Joshua Julia Justin Kaitlyn Katherine Katie Kayla Kaylee Keira Kevin Kyle Kylie Landon Lauren Layla Leah Liam Lillian Lily Logan Lucas Lucy Luke Mackenzie Madeline Madison Maggie Makayla Marissa Mason Matthew Max Maya Mckenna Megan Mia Michael Miles Molly Morgan Natalie Nathan Nevaeh Nicholas Nicole Noah Olivia Owen Paige Parker Patrick Peyton Rachel Rebecca Riley Robert Ryan Sam Samantha Samuel Sarah Savannah Sean Sebastian Seth Sophia Steven Sydney Taylor Thomas Trinity Tristan Tyler Victoria William Wyatt Xavier Zachary Zoe )
    last_names = %w( Smith Johnson Williams Jones Brown Davis Miller Wilson Moore Taylor Anderson Thomas Jackson White Harris Martin Thompson Garcia Martinez Robinson Clark Rodriguez Lewis Lee Walker Hall Allen Young Hernandez King Wright Lopez Hill Scott Green Adams Baker Gonzalez Nelson Carter Mitchell Perez Roberts Turner Phillips Campbell Parker Evans Edwards Collins Stewart Sanchez Morris Rogers Reed Cook Morgan Bell Murphy Bailey Rivera Cooper Richardson Cox Howard Ward Torres Peterson Gray Ramirez James Watson Brooks Kelly Sanders Price Bennett Wood Barnes Ross Henderson Coleman Jenkins Perry Powell Long Patterson Hughes Flores Washington Butler Simmons Foster Gonzales Bryant Alexander Russell Griffin Diaz Hayes )
    email_domains = %w( aol.com bellsouth.net btinternet.com charter.net comcast.net cox.net earthlink.net gmail.com hotmail.co.uk hotmail.com msn.com ntlworld.com rediffmail.com sbcglobal.net shaw.ca verizon.net yahoo.ca yahoo.co.in yahoo.co.uk yahoo.com )
    
    #If data file found, load that file, if not set ddefaults
    groups_hash = data_file ? YAML.load(File.open(data_file)) :
        {
            'Business' => {
            },
            'Residential' => {
            },
            'Hotspot' => {
            }
        }
    
    #charset for alphanumeric passwords and hostnames
    charset = ('A'..'Z').to_a + ('0'..'9').to_a + ('a'..'z').to_a
    
    #how many accounts
    account_count.times {
        #pick a random group
        group = group_select ? group_select : groups_hash.keys.sample
        #group_data = groups_hash[group]
        useplan = UsagePlan.find_by_name(group)

        # randomly choose from the static arrays of names
        fn = first_names[rand(first_names.length)]
        ln = last_names[rand(last_names.length)]

        # create a random password
        p = charset.shuffle!.join[0...10]
        
        # pick a "uid" which is really just used as a suffix for login
        random_uid = rand(9999).to_s
        
        # generate login and email address
        login = fn[0, 1].downcase + ln.downcase + random_uid
        email = fn[0, 1].downcase + ln[0, 1].downcase + random_uid + "@" + email_domains[rand(email_domains.length)]
        
        # create new account object
        u = Account.new(
            :login => login,
            :password => p, :password_confirmation => p,
            :email => email,
            :usage_plan => useplan,
            :first_name => fn,
            :last_name => ln,
            :phone => sprintf('%i%i%i', rand(200...700), rand(100...999), rand(1000...9999)),
            :note => 'Automatically generated by script run by ' + $curr_user
        )
        
        # see if the chosen group has a usage plan
        if useplan
            # usage plan exists, load up the unlimited settings from the plan
            u.do_bill_and_apply_usage_plan
            u.unlimited_usage_mb_up = useplan.quota_plan.unlimited_usage_mb_up
            u.unlimited_usage_mb_down = useplan.quota_plan.unlimited_usage_mb_down
            u.unlimited_usage_minutes = useplan.time_plan.unlimited_usage_minutes
        
            # if time / quota is not unlimited, set the remaining amount to a
            # a fraction of what was originally available in the plan
        
            # first we need to come up with our fractions
            frac_mb_up = rand(0)
            frac_mb_down = rand(0)
            frac_minutes = rand(0)
        
            unless useplan.unlimited_devices
            u.max_devices = useplan.max_devices
            end
        
            unless useplan.quota_plan.unlimited_usage_mb_up
            u.usage_mb_up = useplan.quota_plan.usage_mb_up.to_f * frac_mb_up
            u.mb_up = useplan.quota_plan.usage_mb_up.to_f * (1 - frac_mb_up)
            u.pkts_up = u.mb_up * 1000 * rand(100) + rand(1000)
            end
        
            unless useplan.quota_plan.unlimited_usage_mb_down
            u.usage_mb_down = useplan.quota_plan.usage_mb_down.to_f * frac_mb_down
            u.mb_down = useplan.quota_plan.usage_mb_down.to_f * (1 - frac_mb_down)
            u.pkts_down = u.mb_down * 1000 * rand(100) + rand(1000)
            end
        
            unless useplan.time_plan.unlimited_usage_minutes
            if rand(0) > 0.85
                u.usage_minutes = 0
            else
                u.usage_minutes = useplan.time_plan.usage_minutes.to_f * frac_minutes
            end
            end
        
            if rand(0) > 0.35
            u.logged_in_at = Time.at(Time.new() - (rand(864000) + 15))
            end
        else
            # no usage plan found so we'll just set stuff to unlimited
            u.unlimited_usage_mb_up = true
            u.unlimited_usage_mb_down = true
            u.unlimited_usage_minutes = true
            u.mb_up = rand(2000)
            u.mb_down = rand(100000)
            u.pkts_down = u.mb_down * 1000 * rand(100) + rand(1000)
            u.pkts_up = u.mb_up * 1000 * rand(100) + rand(1000)
            u.unlimited_devices = true
        end
        u.save!

        # assign the account to the group we picked earlier
        account_group = AccountGroup.find_or_initialize_by(name: group)
        account_group.accounts << u unless account_group.accounts.include?(u)
        account_group.priority = account_group.priority ? account_group.priority : 4
        account_group.save!
        begin
            #account_group.save!
        rescue
            #raise "Error saving group - #{$!}"
        end

    }
    
    #Loop to create tokens
    (1..token_count).each do
        #Create new token
        t = Token.new
        t.character_code = rand(4) + 1
        t.length = [8, 12, 16].sample
        
        # pick group membership
        group = group_select ? group_select : groups_hash.keys.sample
        
        # generate a random MAC address
        mac = Mac.random_mac
        
        # generation an IP address
        ipaddr = sprintf("192.168.%i.%i", rand(1...10), rand(1...254))
        
        t.mac = mac
        
        # see if the chosen group has a usage plan
        useplan = UsagePlan.find_by_name(group)
        
        if useplan
        
            # usage plan exists, load up the unlimited settings from the plan
            t.usage_plan = useplan
            t.unlimited_usage_mb_up = useplan.quota_plan.unlimited_usage_mb_up
            t.unlimited_usage_mb_down = useplan.quota_plan.unlimited_usage_mb_down
            t.unlimited_usage_minutes = useplan.time_plan.unlimited_usage_minutes
        
            # if time / quota is not unlimited, set the remaining amount to a
            # a fraction of what was originally available in the plan
        
            # first we need to come up with our fractions
            frac_mb_up = rand(0)
            frac_mb_down = rand(0)
            frac_minutes = rand(0)
        
            unless useplan.quota_plan.unlimited_usage_mb_up
            t.usage_mb_up = useplan.quota_plan.usage_mb_up.to_f * frac_mb_up
            t.mb_up = useplan.quota_plan.usage_mb_up.to_f * (1 - frac_mb_up)
            t.pkts_up = t.mb_up * 1000 * rand(100) + rand(1000)
            end
        
            unless useplan.quota_plan.unlimited_usage_mb_down
            t.usage_mb_down = useplan.quota_plan.usage_mb_down.to_f * frac_mb_down
            t.mb_down = useplan.quota_plan.usage_mb_down.to_f * (1 - frac_mb_down)
            t.pkts_down = t.mb_down * 1000 * rand(100) + rand(1000)
            end
        
            unless useplan.time_plan.unlimited_usage_minutes
            t.usage_minutes = useplan.time_plan.usage_minutes.to_f * frac_minutes
            end
        
        else
        
            # no usage plan found so we'll just set stuff to unlimited
            t.unlimited_usage_mb_up = true
            t.unlimited_usage_mb_down = true
            t.unlimited_usage_minutes = true
            t.mb_up = rand(2000)
            t.mb_down = rand(100000)
            t.pkts_down = t.mb_down * 1000 * rand(100) + rand(1000)
            t.pkts_up = t.mb_up * 1000 * rand(100) + rand(1000)
        
        end
        
        t.no_usage_expiration = true
        
        t.save!
        
        # assign the token to the group we picked earlier
        account_group = AccountGroup.find_or_initialize_by(name: group)
        account_group.accounts << t unless account_group.accounts.include?(t)
        account_group.save!
        
        # generate RRDs for the login, mac and IP
        `/space/rxg/rxgd/debug/gen_user_rrd #{t.login} #{t.mac} #{ipaddr} 1 2`
    end

end